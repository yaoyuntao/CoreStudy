多线程介绍：
	进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于
		运行过程中的程序，并且具有一定独立功能。
	线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个
		进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
	简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程
	
	
什么是多线程呢？即就是一个程序中有多个线程在同时执行。
	单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如，去
			网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。
	多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。

进程与线程的区别：
	1.一个应用程序至少包含一个进程，一个进程至少包含一个线程，线程依赖进程运行

	2.线程不拥有系统资源，多线程共享同一个进程的系统资源
	每个进程运行是互相独立、互不影响的，但进程消耗的资源比线程大

	3.多线程运行，对象被加锁后，影响其他线程执行，可能出现线程死锁等并发问题
	进程间的切换比线程间的切换消耗的CPU时间更大

程序运行原理：
	分时调度
		所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
	抢占式调度
		优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，
	Java使用的为抢占式调度。
	
安全问题：（同步代码块与同步锁）
	1.单线程不会有线程数据安全问题
	2.存在与多个线程同时操作一个共享数据
	解决办法：
		当一个线程进入数据操作时，无论是否休眠，其他线程只能等待，不能操作共享数据。
	同步代码块使用的位置：
		线程的共享数据模块
	英文：c kui nai si te
	synchronized原理：
		当A线程调用run方法执行到同步代码块，先判断同步锁存不存在，如果存在则获得同步锁并执行
	同步代码块中的代码，此时如果A线程休眠，B线程启动执行到同步代码块时，同样判断同步锁存不存
	在，此时发现同步锁不存在，则B线程等待。当A线程执行完同步代码块中的代码后，会把同步锁归还。
	如果B线程再次分配到CPU资源，运行到同步代码块，发现同步锁存在，则B线程获得同步锁，并执行
	同步代码块中的代码。
		总结：
			1.没有锁的线程不会执行同步代码块
			2.获得同步锁的线程，同步代码块中的代码不执行完，不会释放同步锁
		缺点：
			1.使用同步代码块或同步方法。影响代码执行效率
			2.如果同步代码块或同步方法，出现异常抛出了，此时是不会释放锁的。不过使用Lock接口
		可以避免
线程等待与唤醒：
	wait()
	英文：nou tei fai
	notify()
	
Thread类与Runnable接口的区别
	因为Thread类实现了Runnable接口
	new Thread(RunnableImpl runnableImpl和new Thread(ThreadImpl threadimpl).start()是数据共享的
	new ThreadImpl()数据不共享
	由此得知，创建子线程的方式不同，子线程代码中的成员变量是否共享也就不同	
		Runnable实现类中的数据只能共享
		Thread子类中的数据可以共享和不共享，原因就是Thread类实现了Runnable接口，for循环里可以new Thread(ThreadImpl)

	
锁：
	悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，
这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，
表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也
是悲观锁。

　　乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的
时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，
这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中
java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
	
	互斥锁：同一时间，只能有一个线程操作受保护的代码 
		Lock lock = new ReentrantLock();
	公平锁:待运行的线程进行排队，当上一个线程运行完毕后，按队列中的排序运行
		ReentrantLock lock = new ReentrantLock(true);	
	不公平锁：
		ReentrantLock lock = new ReentrantLock(false);默认为false
	